import subprocess
import json
import csv
import argparse
import os
import sys
from pathlib import Path
from typing import List, Dict, Any, Optional
import tempfile
import time
from datetime import datetime

class VulnerabilityAnalysisRunner:
    def __init__(self, database_path: str, output_dir: str = "vulnerability_results", codeql_path: str = "codeql"):
        self.database_path = database_path
        database_name = database_path.split("/")[-1]
        self.output_dir = f"{output_dir}/{database_name}"
        self.codeql_path = codeql_path

        # Automatically discover all .ql files in queries/analysis and subdirectories
        self.queries = []
        analysis_dir = Path("")
        if analysis_dir.exists():
            # Use glob to find all .ql files recursively, excluding wip directories
            self.queries = [str(path) for path in analysis_dir.rglob("*.ql")]
            self.queries.sort()  # Sort for consistent ordering
        else:
            print(f"Warning: Analysis directory {analysis_dir} not found")

        # Ensure output directory exists
        os.makedirs(self.output_dir, exist_ok=True)

    def get_query_name(self, query_path: str) -> str:
        path_parts = Path(query_path).parts
        if len(path_parts) >= 2:
            return f"{path_parts[-2]}/{Path(query_path).stem}"
        return Path(query_path).stem

    def get_output_filename(self, query_path: str) -> str:
        query_name = self.get_query_name(query_path)
        # Replace forward slash with underscore for filename
        safe_name = query_name.replace('/', '_')
        return os.path.join(self.output_dir, f"{safe_name}.csv")

    def get_output_summary_filename(self) -> str:
        return os.path.join(self.output_dir, f"summary.txt")

    def run_single_query_csv(self, query_path: str) -> Optional[str]:
        """Run a single CodeQL query using query run and bqrs decode"""
        print(f"Running query: {query_path}")

        # Add a small delay to ensure previous query has fully released the database
        time.sleep(1)

        output_file = self.get_output_filename(query_path)

        # Create temporary BQRS file
        with tempfile.NamedTemporaryFile(suffix='.bqrs', delete=False) as temp_bqrs:
            temp_bqrs_path = temp_bqrs.name

        try:
            # Step 1: Run the query and store output in BQRS format
            run_cmd = [
                self.codeql_path, "query", "run",
                query_path,
                "--database", self.database_path,
                "--output", temp_bqrs_path
            ]

            print(f" - Step 1: Running query...")
            run_result = subprocess.run(run_cmd, capture_output=True, text=True)

            if run_result.returncode != 0:
                print(f"Warning: Query run failed for {query_path} with return code {run_result.returncode}")
                print(f"Error: {run_result.stderr}")
                return None

            # Step 2: Decode BQRS to CSV
            decode_cmd = [
                self.codeql_path, "bqrs", "decode",
                temp_bqrs_path,
                "--format=csv",
                "--output", output_file
            ]

            print(f" - Step 2: Decoding to CSV...")
            decode_result = subprocess.run(decode_cmd, capture_output=True, text=True)

            if decode_result.returncode != 0:
                print(f"Warning: BQRS decode failed for {query_path} with return code {decode_result.returncode}")
                print(f"Error: {decode_result.stderr}")
                return None

            # Check if file was created and has content
            if os.path.exists(output_file):
                with open(output_file, 'r') as f:
                    lines = f.readlines()
                    result_count = len(lines) - 1 if len(lines) > 1 else 0  # Subtract header
                    print(f"Found {result_count} results for {query_path}")

                    if result_count == 0:
                        print(f"No results found for {query_path}, removing empty file")
                        os.remove(output_file)
                        return None

                return output_file
            else:
                print(f"No output file created for {query_path}")
                return None

        except Exception as e:
            print(f"Error running query {query_path}: {e}")
            return None
        finally:
            # Clean up temporary BQRS file
            if os.path.exists(temp_bqrs_path):
                os.unlink(temp_bqrs_path)
            # Add delay after completion
            time.sleep(0.5)

    def run_all_queries(self) -> List[str]:
        """Run all vulnerability analysis queries and return list of created files"""
        created_files = []
        failed_queries = []

        for query_path in self.queries:
            if not os.path.exists(query_path):
                print(f"Warning: Query file {query_path} not found, skipping...")
                failed_queries.append(query_path)
                continue

            # Use the two-step process for all queries
            output_file = self.run_single_query_csv(query_path)
            output_summary = ""

            if output_file:
                created_files.append(output_file)
            else:
                failed_queries.append(query_path)

        self._write_analysis_summary(created_files, failed_queries)

        return created_files

    def _write_analysis_summary(self, created_files: List[str], failed_queries: List[str]) -> None:
        """Write analysis summary to summary.txt file for the db"""
        # Get database name for the summary
        database_name = os.path.basename(self.database_path)

        summary_file = self.get_output_summary_filename()

        try:
            with open(summary_file, 'w', encoding='utf-8') as f:
                f.write(f"\n{'='*80}\n")
                f.write(f"Analysis Summary for Database: {database_name}\n")
                f.write(f"Output Directory: {self.output_dir}\n")
                f.write(f"{'='*80}\n")

                f.write(f"Total queries: {len(self.queries)}\n")
                f.write(f"Successful: {len(created_files)}\n")
                f.write(f"Failed: {len(failed_queries)}\n")

                if failed_queries:
                    f.write(f"\nFailed queries:\n")
                    for query in failed_queries:
                        f.write(f"  - {query}\n")

                if created_files:
                    f.write(f"\nCreated files:\n")
                    for file in created_files:
                        f.write(f"  - {file}\n")

                f.write(f"\n")  # Add extra newline for separation between databases

            print(f"Analysis summary appended to {summary_file}")

        except Exception as e:
            print(f"Error writing summary to {summary_file}: {e}")
            # Fall back to console output if file writing fails
            print(f"\n=== Analysis Summary ===")
            print(f"Total queries: {len(self.queries)}")
            print(f"Successful: {len(created_files)}")
            print(f"Failed: {len(failed_queries)}")

            if failed_queries:
                print(f"Failed queries: {', '.join(failed_queries)}")

            if created_files:
                print(f"\nCreated files:")
                for file in created_files:
                    print(f"  - {file}")

    def run_analysis(self):
        """Main method to run the complete analysis"""
        print(f"Starting vulnerability analysis on database: {self.database_path}")
        print(f"Output directory: {self.output_dir}")

        # Verify database exists
        if not os.path.exists(self.database_path):
            print(f"Error: Database path {self.database_path} does not exist")
            return False

        # Run queries
        created_files = self.run_all_queries()

        if created_files:
            print(f"\nAnalysis complete. Created {len(created_files)} result files.")
            return True
        else:
            print(f"\nAnalysis complete. No result files were created.")
            return False


def main():
    parser = argparse.ArgumentParser(description='Run CodeQL vulnerability analysis queries')
    parser.add_argument('database', help='Path to CodeQL database')
    parser.add_argument('-o', '--output-dir', default='vulnerability_results',
                       help='Output directory for CSV files (default: vulnerability_results)')
    parser.add_argument('--codeql-path', default='codeql',
                       help='Path to CodeQL CLI (default: codeql)')

    args = parser.parse_args()

    # Run individual queries
    runner = VulnerabilityAnalysisRunner(args.database, args.output_dir, args.codeql_path)
    success = runner.run_analysis()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
